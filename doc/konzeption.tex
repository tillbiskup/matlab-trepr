\documentclass{article}
\usepackage{german}
\usepackage[paper=a4paper,margin=1in]{geometry}
\usepackage[utf8]{inputenc}

\usepackage{textcomp}

\usepackage{natbib}

\usepackage{amsmath}

\newcommand{\vect}[1]{\boldsymbol{\mathrm #1}}

\title{trEPR--Messungen: Konzeption der Auswertungsroutinen}
\author{Till Biskup}
\date{\today, $ $Revision$ $}


\def\matlab{\textsf{MATLAB}$^\mbox{\tiny\textregistered}$}
\def\octave{\textsf{GNU Octave}}
\def\robodoc{\textsf{ROBODoc}}
\def\fscii{\texttt{fsc2}}

\newcommand{\func}[1]{\texttt{#1}}
\newcommand{\cmd}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\var}[1]{\texttt{#1}}

\newenvironment{Quote}{\begin{quote}\small\vspace*{1em}\hrule\vspace*{1ex}
}{\end{quote}\hrule\vspace*{1em}}
%\renewenvironment{quote}{\begin{Quote}}{\end{Quote}}

\begin{document}
\maketitle\thispagestyle{empty}

\begin{abstract}
  Die folgenden Ausführungen sind eine kurze Zusammenfassung der Konzeption
  eines Auswertungsprogramms für die Daten aus transienten EPR--Messungen.
  Zunächst werden die grundlegenden Ideen für die Umsetzung kurz aufgeführt,
  anschließend die einzelnen Programmblöcke detaillierter erklärt. Ausgehend von
  dieser Dokumentation sollte es möglich sein, ein entsprechendes Programm in
  \matlab\ zu erstellen. 
\end{abstract}

\begin{small}
\tableofcontents 
\end{small}

\section{Grundsätzliches}

\begin{itemize}
  \item Aufteilung der einzelnen Programmblöcke in einzelne \matlab--Funktionen
  \item Dokumentation jeder einzelnen Funktion (am besten mit \robodoc) \emph{in Englisch}
  \item Interaktive Abfrage von Parametern nicht in den Kernfunktionen, sondern
  in eigenen ``Treiber--Funktionen'' bzw. in einem ```Meta--Skript'', das die 
  einzelnen Funktionen in der richtigen Reihenfolge aufruft
  \item Logging aller Einzelschritte und wichtigen Werte in einer Log--Datei
  (ähnlich einer \textsf{gaussian}--Aus\-gabedatei)\\
  Kann in einem ersten Schritt mit der Funktion \texttt{diary} von
  \matlab/\octave\ realisiert werden (vorausgesetzt im ``Meta--Skript'' sind
  entsprechende zusätzliche Ausgaben programmiert).
  \item Versionsverwaltung (CVS bzw. Subversion) der einzelnen Skripte\\
  Die jeweils aktuelle Fassung aller Dateien (inkl. Dokumentation) liegt auf
  einer Homepage im Internet. Die eigentliche Entwicklungsarbeit an den
  Kernfunktionen (und damit gleichzeitig mit der Versionsverwaltung) beschränkt
  sich auf einen kleinen Benutzerkreis.
  \item ``Meta--Skript'', das auf die einzelnen Funktionen zurückgreift und
  einen Datensatz komplett analysiert (später durch --- in \matlab\
  programmierte --- GUI ersetzbar)
  \item Nach Möglichkeit für die nichtgrafischen Teile (alle Kernfunktionen) Kompatibilität zu
  \octave
\end{itemize}


\section{Beschreibung der Kernfunktionen}

Die Funktionalität wird nicht wie bisher durch ein Gesamtprogramm
bereitgestellt, sondern durch mehrere kleine Funktionen (``Kernfunktionen''), die jeweils eine
einzige Aufgabe erfüllen. Diese Kernfunktionen erhalten alle notwendigen
Parameter durch ihren Aufruf, sie besitzen selbst keine Strukturen, die
interaktiv nach solchen Parametern fragen.

Ziel der Beschreibung ist neben der Darstellung der einzelnen Funktionsbereiche
und der Aufteilung die Darlegung des allgemeinen Vorgehens bei der Datenanalyse.


\subsection{Rohdaten einlesen}

\begin{description}
  \item[Funktion] Liest die vom Spektrometer kommenden Rohdaten (1D) ein und wandelt
  sie in ein 2D--Array um.
  \item[Übergabe-Parameter] Dateiname
  \item[Rückgabewert] 2D--Array
\end{description}

Die Spektrometer--Software (\fscii) schreibt an den Beginn der Daten--Datei
zunächst das Skript, mit dem die Daten aufgenommen wurden (durch ``\%''--Zeichen
auskommentiert für \matlab) und darunter in einer einzigen Spalte (1D) alle
aufgezeichneten Werte.

Gemessen wird für jeden $B_0$--Wert eine Zeitkurve mit einer definierten Zahl
von Werten. Die Zahl der Werte pro Zeitkurve ($t$--Dimension), der Bereich des
durchfahrenen $B_0$--Feldes und dessen Schrittweite ($B_0$--Dimension) werden am
Ende des auskommentierten Bereiches vor den eigentlichen Daten ausgegeben.
Sinnvollerweise werden diese Daten nicht per Hand eingegeben, sondern von hier ausgelesen.

Im Folgenden ist ein Ausschnitt einer solchen Datendatei wiedergegeben. Sehr zur
Vereinfachung des Auslesens trägt die Kennzeichnung der einzelnen Parameter
durch die vorangestellten Bezeichner bei. Unterhalb der Parameter erscheint der
vor der eigentlichen Messung vom Benutzer eingegebene Kommentar.

\begin{Quote}
\begin{verbatim}
% 
% Number of runs     = 1
% Start field        = 3410.00000 G
% End field          = 3510.00000 G
% Field step width   = 0.500000000 G
% Sensitivity        = 5.00000000 mV/div
% Number of averages = 20
% Time base          = 2.00000000 us/div
% Number of points   = 500
% Trigger position   = 50
% Slice length       = 20.0000000 us
% 
% 9,68455 GHz
% 20 dB
% 274 K
% 460 nm (1/8)
% 
0.000650009918
\end{verbatim}
\end{Quote}



\subsection{Reihenfolge anpassen}

\begin{description}
  \item[Funktion] Ordnet die Daten (2D--Array) nach aufsteigendem $B_0$--Wert an
  \item[Übergabe-Parameter] 2D--Array
  \item[Rückgabewert] 2D--Array
\end{description}

Gemessen wird meist symmetrisch: Einmal wird das $B_0$--Feld in aufsteigender,
einmal in absteigender Richtung durchfahren. Zur weiteren Verarbeitung ist es
aber notwendig, daß alle Datensätze in der gleichen Sortierung vorliegen.


\subsection{Akkumulation}

\begin{description}
  \item[Funktion] Aufakkumulation mehrerer Messungen
  \item[Übergabe-Parameter] mehrere 2D--Arrays mit Daten
  \item[Rückgabewert] 2D--Array mit aufakkumulierten Daten
\end{description}

Zur Verbesserung des Signal--Rausch--Abstandes werden mehrere Messungen aufakkumuliert.


\subsection{Offset--Korrektur über Pretrigger--Signal}

\begin{description}
  \item[Funktion] Offset--Korrektur des Signals über die Pretrigger--Zeit
  \item[Übergabe-Parameter] 2D--Array mit Daten, Pretrigger-Zeit
  \item[Rückgabewert] 2D--Array, offset--korrigiert
\end{description}

Langsame Oszillationen oder Drifts (Temperaturschwankungen, Erschütterungen, etc.)
werden durch Abziehen eines Offsets korrigiert. Das Offset wird über die vor dem
Laserpuls aufgenommenen Datenpunkte der Zeitkurve (deren Anzahl steht am Ende
des einleitenden Kommentars der Datendatei) ermittelt.


\subsection{Integration eines 1D--Spektrums ($B_0$)}

\begin{description}
  \item[Funktion] Optimale Integration eines 1D--$B_0$--Spektrums zu einem
  definierten Zeitpunkt $t$
  \item[Übergabe-Parameter] 2D--Array mit Daten, Zeitpunkt $t$, Integrationsbereich
  \item[Rückgabewert] integriertes 1D--Spektrum
\end{description}

Oft werden nicht 2D--Spektren, sondern 1D--$B_0$--Spektren zu festen Zeiten $t$ 
ausgewertet. Für einen verbesserten Signal--Rausch--Abstand wird rund um einen 
gegebenen Zeitpunkt $t$ das Signal aufintegriert. Es gibt ein optimales 
Integrationsintervall innerhalb des vorgegebenen Integrationsbereiches, das den 
Signal--Rausch--Abstand maximiert. Die Funktion optimiert die Integration unter 
den gegebenen Parametern auf dieses optimale Integrationsintervall und gibt das 
geglättete 1D--Spektrum zurück


\subsection{$B_0$--Drift--Korrektur}

Häufig zeigen die Spektren eine Drift über die gesamte Messung. Das ist auch 
der Grund für die symmetrische Aufnahme (s.o.). Die Korrektur dieser Drift ist 
nichttrivial, da sie normalerweise erst zeitlich nach dem Trigger--Puls auftritt
(das Pretrigger--Offset driftet nicht). Daher werden im folgenden zwei Routinen
vorgestellt, die diese Drift entlang beider Dimensionen ($B_0$ und $t$)
korrigieren.

\subsubsection{$B_0$--Drift--Korrektur entlang $t$}

\begin{description}
  \item[Funktion] Korrektur der $B_0$--Drift entlang der $t$--Achse
  \item[Übergabe-Parameter] 2D--Array, Anzahl der zu verwendenden 
  Dunkelsignal--Zeitkurven
  \item[Rückgabewert] 2D--Array, drift--korrigiert
\end{description}

Um die Drift als solche zu charakterisieren, wird das $B_0$--Signal über die
letzten Zeitpunkte gemittelt und (linear bzw. quadratisch) gefittet. Das
gefittete Polynom (linear oder quadratisch) wird für alle Zeitpunkte vom Signal
abgezogen. Dabei tritt das Problem auf, daß das (bereits korrigierte, driftfreie)
Pretrigger--Offset wieder mit einer Drift überlagert wird. Die Lösung für dieses
Problem liegt in einer entlang $t$ gewichteten Drift--Korrektur.

Entlang der $t$--Achse lassen sich (für einen Bereich von $B_0$, in dem kein
Signal beobachtet wird) drei Bereiche unterscheiden:
\begin{enumerate}
  \item Zeit vor dem Trigger--Puls $t_0$
  \item Zeit zwischen dem Trigger--Puls $t_0$ und dem Erreichen des (stabilen)
  Wertes nach dem Trigger (Zeitpunkt $t_1$)
  \item Zeit zwischen $t_1$ und $t$ (dem Ende der $t$--Achse)
\end{enumerate}

Zur entlang $t$ gewichteten Drift--Korrektur muß in einem ersten Schritt der
Zeitpunkt $t_1$ bestimmt werden, anschließend können die Vektoren mit den 
Gewichten erstellt werden, die dann für die Drift--Korrektur zum Einsatz kommen.

Das Intervall zwischen $t_0$ (Trigger--Impuls) und $t_1$ sollte möglichst kurz
gehalten werden, um das Signal, das zügig nach $t_0$ einsetzt, möglichst nicht
zu beeinflussen.

Zur Bestimmung von $t_1$ wird folgendes Vorgehen vorgeschlagen:
\begin{enumerate}
  \item Berechnung des (arithmetischen) Mittels und der Standardabweichung für
  das Signal deutlich nach dem Trigger bis zum Ende der $t$--Achse.
%  \item Berechnung des (arithmetischen) Mittels vom Offset
\item Inkrementeller Vergleich des Signals entlang $t$ ab $t_0$, bis es dem Wert
für das (stabile) Signal nach dem Trigger entspricht (als Referenz für das
stabile Signal wird der um die Standardabweichung des stabilen Signals
verringerte Mittelwert des stabilen Signals verwendet).
\item Wenn das Signal $\geq$ der Referenz ist, ist der Zeitpunkt $t_1$ gefunden.
\end{enumerate}

In einem zweiten Schritt können die beiden Gewichts--Vektoren (\var{offset\_weights}
und \var{drift\_weights}) erstellt werden. Grundsätzlich gilt:

\begin{align*}
  \text{\var{offset\_weights}} &= 1 & \forall & \quad t=0 \leq t \leq t_0\\ 
  \text{\var{offset\_weights}} &= 1\dots 0 & \forall & \quad t_0 < t \leq t_1\\
  \text{\var{offset\_weights}} &= 0 & \forall & \quad t_1 < t \leq t_\text{max}
\end{align*}

Umgekehrt gilt dasselbe für \var{drift\_weights}. Für den Bereich zwischen $t_0$
und $t_1$ wird ein linearer Anstieg (\var{slope\_of\_weights}) angenommen: 

\begin{Quote}
\begin{verbatim}
  slope_of_weights = 1 / ( t1 - t0 )
  
  for i = ( t0 : t1 )
  
    offset_weights(i) = i * slope_of_weights;
    drift_weights(i) = 1 - ( i * slope_of_weights );
  
  end    
\end{verbatim}
\end{Quote}


\subsubsection{$B_0$--Drift--Korrektur entlang $B_0$}

\begin{description}
  \item[Funktion] Korrektur der $B_0$--Drift entlang der $B_0$--Achse
  \item[Übergabe-Parameter] 2D--Array, Anzahl der zu verwendenden 
  Dunkelsignal--Zeitkurven
  \item[Rückgabewert] 2D--Array, drift--korrigiert
\end{description}

Häufig zeigen die Spektren eine Drift über die gesamte Messung. Das ist auch der
Grund für die symmetrische Aufnahme (s.o.). Zur Korrektur dieser Drift werden
zwei (gleich lange) $B_0$--Intervalle am Anfang und Ende des Spektrums
ausgewählt (\emph{per definitionem} kein Signal), gemittelt und diese
Mittelwerte zur Drift--Korrektur verwendet.

Die beiden Korrekturwerte von Anfang und Ende des Spektrums werden gegenläufig
gewichtet: Zu Beginn trägt nur der Mittelwert vom Anfang des Spektrums zur
Driftkorrektur bei, sein Beitrag fällt mit fortschreitendem $B_0$ linear ab,
gleichzeitig steigt der Beitrag des Mittelwertes vom Ende des Spektrums linear
an, um am Ende des Spektrums sein Maximum zu erreichen.


\section{Umsetzung der einzelnen Funktionen}

Während in den vorangegangenen Abschnitten mehr allgemeine Aspekte im
Vordergrund standen, sollen in diesem Abschnitt konkrete umsetzungsspezifische
Details aufgelistet werden.


\subsection{Grundlegendes}

\subsubsection{Aufteilung in einzelne Blöcke}

\matlab\ erlaubt die Deklaration von Funktionen in den sogenannten M--Files. In 
jeder solchen Datei gibt es nur \emph{eine} Haupt--Funktion und berliebig viele 
Unterfunktionen, auf die dann nur die Hauptfunktion (die an erster Stelle in 
der Datei stehen muß) zugreifen kann.


\subsubsection{Logging}

\matlab\ stellt grundsätzlich zwei Möglichkeiten bereit, alle Ausgaben in einer 
separaten Datei zu speichern: über einen Parameter beim Start von \matlab, der 
alle Ausgaben in eine dort zu definierende Datei mitschreibt, oder über die 
(deutlich komfortablere) Funktion \func{diary}, die als Parameter einen 
Dateinamen erwartet \cite[S. 124]{TheMathWorks:2005ah}:

\begin{Quote}
To create a file on your disk called \texttt{sept23.out} that contains 
all the functions you enter, as well as MATLAB output, enter 
\begin{verbatim} 
    diary('sept23.out') 
\end{verbatim}
To stop recording the session, use 
\begin{verbatim} 
    diary('off') 
\end{verbatim}
To view the file, run 
\begin{verbatim} 
    edit('sept23.out') 
\end{verbatim}
\end{Quote}

Eine einfache Möglichkeit, bei jedem Funktionsaufruf die Revisionsnummer und das
Revisionsdatum mit in der diary--Datei stehen zu haben, ist, vor dem jeweiligen
Funktionsaufruf im Meta--Skript den Befehl ``\cmd{help <funktionsname>}'' aufzurufen.

Wird neben den Daten gemeinsam mit der Log--Datei das Meta--Skript abgelegt,
sollten sich einfach und konfortabel die Verarbeitugnsschritte wiederholen und
gegebenenfalls modifizieren lassen.


\subsubsection{Meta--Skript}

Das Meta--Skript fragt die notwendigen Parameter vom Nutzer ab und stößt die
weitere Datenverarbeitung an. Dieses Skript kann (zumindest am Anfang)
für jeden Datensatz angepaßt werden.

Eine eventuell zu programmierende GUI setzt ebenfalls auf dieser Ebene an. Die
GUI ersetzt quasi das Meta--Skript. Mittlerweile sind GUI--Fähigkeiten für
\octave\ in Entwicklung, so daß die prinzipielle Möglichkeit besteht, eine frei
verfügbare Version der Auswertungssoftware über \octave\ zu realisieren.


\subsubsection{Versionsverwaltung}

Via CVS oder Subversion \cite{Collins-Sussman:2005qs}. Jede Funktion gibt bei 
ihrem Aufruf ihre jeweilige Revisionsnummer und nach Möglichkeit auch das Datum 
der Revision aus, um auch im Nachhinein noch nachvollziehen zu können, welche 
Version der Funktion bei der Datenverarbeitung verwendet wurde.

Wichtig ist bei der Verwendung der Versionsverwaltung die Angabe kurzer, aber
sinnvoller und treffender Kommentare bei jedem ``commit''--Vorgang.

\matlab\ erlaubt über eingebaute Funktionen den direkten Zugriff auf
Versionsverwaltungssysteme (und zumindest unter UNIX/Linux auch auf CVS)
\cite[S. 431]{TheMathWorks:2005ah}.


\subsubsection{Dokumentation}

Jede \matlab\--Funktion kann durch Eingabe eines Kommentars direkt hinter der 
Funktions--Deklaration grob dokumentiert werden. Zu den unbedingt notwendigen 
Angaben gehören:

\begin{enumerate}
  \item kurze Beschreibung, was die Funktion tut
  \item Eingabe--Parameter (Anzahl, Typ)
  \item Ausgabe--Parameter (Anzahl, Typ)
\end{enumerate}

Eine ausführlichere Dokumentation sollte ebenfalls direkt im Quellcode mittels 
\robodoc\ \cite{Slothouber:2005hs} (oder einem anderen Automatisierungs--Tool 
für Dokumentationen) erfolgen.



\subsection{Kernfunktionen}

Die Kernfunktionen sind diejenigen Funktionen, die die eigentliche
Datenverarbeitung und --analyse bewerkstelligen. Jede dieser Funktionen wird in
einem eigenen (gleichnamigen) M--File abgelegt und dokumentiert.

Vorrangiges Ziel ist es, die so modularisierten Funktionen zu optimieren und
danach von der Programmentwicklung her weitestgehend einzufrieren.


\subsubsection{Einlesen der Rohdaten}

Die einfachste Variante, unter \matlab\ die von der Spektrometer--Software
geschriebenen Daten direkt einzulesen, ist die Funktion \func{load}. Diese
Funktion liest den Inhalt der als Parameter übergebenen Datei in eine Variable
mit demselben Namen (ohne Dateiendung). Ein Beispiel:
%
\begin{Quote}
\begin{verbatim}
load data.dat 
\end{verbatim} 
\end{Quote}
%
liest die Daten in der Datei \file{data.dat} in die Variable \var{data} ein. Das
löst allerdings noch nicht das Problem, wie die zusätzlichen Informationen, die
im Kommentar am Beginn der Datendatei stehen und die zur weiteren Verarbeitung
der Daten von Interesse sind, von \matlab\ automatisiert eingelesen werden
können. 

Für das Einlesen dieser Daten stehen eine Reihe von ``low
level'' Datei--Ein/Ausgabe--Funktionen und entsprechende
Stringmanipulations--Funktionen zur Verfügung, vgl. Tab. \ref{tab:fileIO}.

\begin{table}
\begin{tabular*}{\textwidth}{ll}
\hline
\\[-1ex]
Funktion & Beschreibung\\[-1ex]
\\\hline
\\[-1ex]
\cmd{fopen} & Datei öffnen\\
\cmd{fclose} & Datei schließen\\
\cmd{fgetl} & Zeile aus Datei einlesen, Zeilenende--Zeichen verwerfen\\[-1ex]
\\\hline
\\[-1ex]
\cmd{findstr} & finde einen String in einem anderen
\\[-1ex]
\\\hline
\end{tabular*}
\caption{Übersicht über einige ``Low--level'' Datei--Ein/Ausgabe--Funktionen und
String--Manipulations\-funktionen von \matlab, wie sie zum Auslesen der
zusätzlichen Informationen aus der Datendatei verwendet werden können.}
\label{tab:fileIO}
\end{table}


\subsubsection{Anpassen der Reihenfolge der Daten}

Ist in der Funktion, die die Daten einliest, gleich mit implementiert worden.


\subsubsection{Akkumulation mehrerer Spektren}

Da die Spektren häufig unterschiedliche Signal--Rausch--Abstände haben, werden 
sie nicht einfach addiert, da sonst die Gefahr besteht, daß die Messungen mit 
geringem Rauschen und hohem Signal--Rausch--Abstand tendenziell schlechter 
werden.

Eine pragmatische Lösung ist, zwei Spektren gewichtet aufzuaddieren:

\begin{align*}
	\vect{C} &= \vect{A} + x \vect{B}
\end{align*}

Der Parameter $x$ wird dadurch optimiert, daß er über das Intervall $0 < x < 1$
variiert wird und für jeden Wert von $x$ das Verhältnis von maximaler Amplitude
zu Rauschen bestimmt wird. $x$ gilt dann als optimiert, wenn dieses Verhältnis
maximiert ist.

Für jede weitere aufzuaddierende Matrix wird dasselbe Verfahren angewandt.


\subsubsection{Offset--Korrektur über Pretrigger--Signal}


\subsubsection{Integration eines 1D--Spektrums ($B_0$)}


\subsubsection{Drift--Korrekur über das Dunkelsignal}


\bibliographystyle{abbrv}%bioscript-authors}
\bibliography{literatur}

\end{document}